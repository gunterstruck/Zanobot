{"version":3,"file":"data-CHglu3FA.js","sources":["../../src/utils/logger.ts","../../src/data/db.ts"],"sourcesContent":["/**\n * ZANOBOT - CENTRALIZED LOGGING UTILITY\n *\n * Provides conditional logging based on environment.\n * In production, console logs are suppressed to reduce noise and improve performance.\n *\n * Usage:\n *   import { logger } from '@utils/logger.js';\n *   logger.info('User action', { machineId: '123' });\n *   logger.error('API failure', error);\n *   logger.debug('Debug info', data);\n */\n\n/**\n * Log levels\n */\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  NONE = 4,\n}\n\n/**\n * Logger configuration\n */\ninterface LoggerConfig {\n  level: LogLevel;\n  enableTimestamp: boolean;\n  enableStackTrace: boolean;\n}\n\n/**\n * Default configuration based on environment\n */\nconst getDefaultConfig = (): LoggerConfig => {\n  const isDevelopment = import.meta.env.DEV || import.meta.env.MODE === 'development';\n\n  return {\n    level: isDevelopment ? LogLevel.DEBUG : LogLevel.WARN,\n    enableTimestamp: true,\n    enableStackTrace: isDevelopment,\n  };\n};\n\n/**\n * Logger class\n */\nclass Logger {\n  private config: LoggerConfig;\n\n  constructor(config?: Partial<LoggerConfig>) {\n    this.config = { ...getDefaultConfig(), ...config };\n  }\n\n  /**\n   * Update logger configuration\n   */\n  public configure(config: Partial<LoggerConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Debug log (development only)\n   */\n  public debug(message: string, ...args: unknown[]): void {\n    if (this.config.level <= LogLevel.DEBUG) {\n      this.log('DEBUG', message, args, console.debug);\n    }\n  }\n\n  /**\n   * Info log\n   */\n  public info(message: string, ...args: unknown[]): void {\n    if (this.config.level <= LogLevel.INFO) {\n      this.log('INFO', message, args, console.log);\n    }\n  }\n\n  /**\n   * Warning log\n   */\n  public warn(message: string, ...args: unknown[]): void {\n    if (this.config.level <= LogLevel.WARN) {\n      this.log('WARN', message, args, console.warn);\n    }\n  }\n\n  /**\n   * Error log\n   */\n  public error(message: string, error?: Error | unknown, ...args: unknown[]): void {\n    if (this.config.level <= LogLevel.ERROR) {\n      const errorInfo = error instanceof Error ? error.message : String(error);\n      const stack =\n        error instanceof Error && this.config.enableStackTrace ? error.stack : undefined;\n\n      this.log('ERROR', message, [errorInfo, ...args], console.error);\n\n      if (stack) {\n        console.error('Stack trace:', stack);\n      }\n    }\n  }\n\n  /**\n   * Internal log method\n   */\n  private log(level: string, message: string, args: unknown[], logFn: (...data: unknown[]) => void): void {\n    const timestamp = this.config.enableTimestamp ? new Date().toISOString() : '';\n    const prefix = timestamp ? `[${timestamp}] [${level}]` : `[${level}]`;\n\n    if (args.length > 0) {\n      logFn(prefix, message, ...args);\n    } else {\n      logFn(prefix, message);\n    }\n  }\n}\n\n/**\n * Global logger instance\n */\nexport const logger = new Logger();\n\n/**\n * Shorthand logging functions (for convenience)\n */\nexport const log = {\n  debug: (message: string, ...args: unknown[]) => logger.debug(message, ...args),\n  info: (message: string, ...args: unknown[]) => logger.info(message, ...args),\n  warn: (message: string, ...args: unknown[]) => logger.warn(message, ...args),\n  error: (message: string, error?: Error | unknown, ...args: unknown[]) =>\n    logger.error(message, error, ...args),\n};\n","/**\n * ZANOBOT - DATABASE LAYER\n *\n * IndexedDB wrapper for offline-first data persistence.\n * Stores machines, recordings, and diagnosis results locally.\n *\n * Uses the idb library for simpler IndexedDB operations.\n */\n\nimport { openDB, DBSchema, IDBPDatabase } from 'idb';\nimport type { Machine, Recording, DiagnosisResult, GMIAModel } from './types.js';\nimport { logger } from '@utils/logger.js';\n\n/**\n * Database schema definition\n */\ninterface ZanobotDB extends DBSchema {\n  machines: {\n    key: string;\n    value: Machine;\n    indexes: {\n      'by-name': string;\n      'by-created': number;\n    };\n  };\n  recordings: {\n    key: string;\n    value: Recording;\n    indexes: {\n      'by-machine': string;\n      'by-timestamp': number;\n    };\n  };\n  diagnoses: {\n    key: string;\n    value: DiagnosisResult;\n    indexes: {\n      'by-machine': string;\n      'by-timestamp': number;\n      'by-machine-timestamp': [string, number];\n      'by-status': DiagnosisResult['status'];\n    };\n  };\n}\n\nconst DB_NAME = 'zanobot-db';\nconst DB_VERSION = 5; // Incremented for Visual Positioning Assistant (referenceImage field)\n\nlet dbInstance: IDBPDatabase<ZanobotDB> | null = null;\n\n/**\n * Initialize and open the database\n *\n * @returns Database instance\n */\nexport async function initDB(): Promise<IDBPDatabase<ZanobotDB>> {\n  if (dbInstance) {\n    return dbInstance;\n  }\n\n  dbInstance = await openDB<ZanobotDB>(DB_NAME, DB_VERSION, {\n    upgrade(db, oldVersion, newVersion, transaction) {\n      // Create machines store\n      if (!db.objectStoreNames.contains('machines')) {\n        const machineStore = db.createObjectStore('machines', { keyPath: 'id' });\n        machineStore.createIndex('by-name', 'name');\n        machineStore.createIndex('by-created', 'createdAt');\n      }\n\n      // Create recordings store\n      if (!db.objectStoreNames.contains('recordings')) {\n        const recordingStore = db.createObjectStore('recordings', { keyPath: 'id' });\n        recordingStore.createIndex('by-machine', 'machineId');\n        recordingStore.createIndex('by-timestamp', 'timestamp');\n      }\n\n      // Create or migrate diagnoses store\n      if (!db.objectStoreNames.contains('diagnoses')) {\n        // Fresh install: create with correct keyPath\n        const diagnosisStore = db.createObjectStore('diagnoses', { keyPath: 'id' });\n        diagnosisStore.createIndex('by-machine', 'machineId');\n        diagnosisStore.createIndex('by-timestamp', 'timestamp');\n        diagnosisStore.createIndex('by-machine-timestamp', ['machineId', 'timestamp']);\n        diagnosisStore.createIndex('by-status', 'status');\n      }\n\n      // Migration from v1 to v2: Fix keyPath if upgrading from old version\n      // SIMPLIFIED MIGRATION: Due to race condition issues with asynchronous cursor operations\n      // in the synchronous upgrade callback, we simply recreate the store.\n      // This results in data loss for v1 users, but prevents database corruption.\n      if (db.objectStoreNames.contains('diagnoses') && oldVersion < 2) {\n        logger.warn('üîÑ Migrating diagnoses store from v1 to v2');\n        logger.warn(\n          '   ‚ö†Ô∏è Old diagnosis data will be lost due to schema change (keyPath: timestamp ‚Üí id)'\n        );\n\n        try {\n          // Delete old store with incorrect keyPath\n          db.deleteObjectStore('diagnoses');\n\n          // Create new store with correct keyPath\n          const diagnosisStore = db.createObjectStore('diagnoses', { keyPath: 'id' });\n          diagnosisStore.createIndex('by-machine', 'machineId');\n          diagnosisStore.createIndex('by-timestamp', 'timestamp');\n          diagnosisStore.createIndex('by-machine-timestamp', ['machineId', 'timestamp']);\n          diagnosisStore.createIndex('by-status', 'status');\n\n          logger.info('   ‚úÖ Diagnoses store recreated with correct schema');\n        } catch (error) {\n          logger.error('   ‚ùå Migration error:', error);\n          // Ensure store exists even on error\n          if (!db.objectStoreNames.contains('diagnoses')) {\n            const diagnosisStore = db.createObjectStore('diagnoses', { keyPath: 'id' });\n            diagnosisStore.createIndex('by-machine', 'machineId');\n            diagnosisStore.createIndex('by-timestamp', 'timestamp');\n            diagnosisStore.createIndex('by-machine-timestamp', ['machineId', 'timestamp']);\n            diagnosisStore.createIndex('by-status', 'status');\n          }\n        }\n      }\n\n      // Migration from v2 to v3: Multiclass diagnosis - HARD RESET\n      // Breaking change: referenceModel ‚Üí referenceModels[] + label field\n      // We cannot migrate old single-model data to multiclass, so we clear everything\n      if (oldVersion < 3) {\n        logger.warn('üîÑ Migrating database from v2 to v3 (Multiclass Diagnosis)');\n        logger.warn('   ‚ö†Ô∏è BREAKING CHANGE: referenceModel ‚Üí referenceModels[]');\n        logger.warn('   ‚ö†Ô∏è All existing data will be cleared (machines, recordings, diagnoses)');\n\n        // CRITICAL: Store migration info in localStorage to show user warning\n        // This will be displayed on next page load in main.ts\n        try {\n          localStorage.setItem('zanobot-migration-v3-occurred', JSON.stringify({\n            timestamp: Date.now(),\n            oldVersion,\n            newVersion: 3,\n            dataCleared: true\n          }));\n        } catch (e) {\n          logger.error('   ‚ùå Could not save migration info to localStorage:', e);\n        }\n\n        try {\n          // Clear all stores to start fresh\n          const machineStore = transaction.objectStore('machines');\n          const recordingStore = transaction.objectStore('recordings');\n          const diagnosisStore = transaction.objectStore('diagnoses');\n\n          machineStore.clear();\n          recordingStore.clear();\n          diagnosisStore.clear();\n\n          logger.info('   ‚úÖ Database reset complete - ready for multiclass diagnosis');\n          logger.warn('   ‚ö†Ô∏è IMPORTANT: All previous data has been deleted due to schema incompatibility');\n          logger.warn('   ‚ÑπÔ∏è You will need to re-record reference audio for all machines');\n        } catch (error) {\n          logger.error('   ‚ùå Migration error:', error);\n        }\n      }\n\n      // Migration from v3 to v4: Add compound index for machine + timestamp\n      if (oldVersion < 4 && db.objectStoreNames.contains('diagnoses')) {\n        const diagnosisStore = transaction.objectStore('diagnoses');\n        if (!diagnosisStore.indexNames.contains('by-machine-timestamp')) {\n          diagnosisStore.createIndex('by-machine-timestamp', ['machineId', 'timestamp']);\n          logger.info('   ‚úÖ Added compound index: by-machine-timestamp');\n        }\n      }\n\n      // Migration from v4 to v5: Visual Positioning Assistant\n      // NON-BREAKING CHANGE: Added optional referenceImage field to Machine interface\n      // No data migration required - existing machines will simply not have this field\n      if (oldVersion < 5) {\n        logger.info('üîÑ Migrating database from v4 to v5 (Visual Positioning Assistant)');\n        logger.info('   ‚úÖ Added optional referenceImage field to Machine schema');\n        logger.info('   ‚ÑπÔ∏è Existing machines will work without changes (non-breaking)');\n      }\n    },\n  });\n\n  logger.info('‚úÖ Database initialized');\n\n  return dbInstance;\n}\n\n// ============================================================================\n// MACHINE OPERATIONS\n// ============================================================================\n\n/**\n * Save or update a machine\n *\n * @param machine - Machine object\n */\nexport async function saveMachine(machine: Machine): Promise<void> {\n  const db = await initDB();\n  await db.put('machines', machine);\n  logger.info(`üíæ Machine saved: ${machine.id}`);\n}\n\n/**\n * Get machine by ID\n *\n * @param id - Machine ID\n * @returns Machine or undefined\n */\nexport async function getMachine(id: string): Promise<Machine | undefined> {\n  const db = await initDB();\n  return await db.get('machines', id);\n}\n\n/**\n * Get all machines\n *\n * @returns Array of all machines\n */\nexport async function getAllMachines(): Promise<Machine[]> {\n  const db = await initDB();\n  return await db.getAll('machines');\n}\n\n/**\n * Delete machine and all associated data\n *\n * @param id - Machine ID\n */\nexport async function deleteMachine(id: string): Promise<void> {\n  const db = await initDB();\n\n  // Delete machine\n  await db.delete('machines', id);\n\n  // Delete associated recordings\n  const recordings = await db.getAllFromIndex('recordings', 'by-machine', id);\n  for (const recording of recordings) {\n    await db.delete('recordings', recording.id);\n  }\n\n  // Delete associated diagnoses\n  const diagnoses = await db.getAllFromIndex('diagnoses', 'by-machine', id);\n  for (const diagnosis of diagnoses) {\n    await db.delete('diagnoses', diagnosis.id); // id is the key\n  }\n\n  logger.info(`üóëÔ∏è Machine deleted: ${id}`);\n}\n\n/**\n * Add a reference model to a machine's model collection\n *\n * @param machineId - Machine ID\n * @param model - GMIA model to add\n */\nexport async function updateMachineModel(machineId: string, model: GMIAModel): Promise<void> {\n  const db = await initDB();\n  const machine = await db.get('machines', machineId);\n\n  if (!machine) {\n    throw new Error(`Machine not found: ${machineId}`);\n  }\n\n  // CRITICAL FIX: Initialize referenceModels array if it doesn't exist\n  // This handles legacy data from old versions or imported data\n  if (!machine.referenceModels) {\n    logger.warn(`‚ö†Ô∏è Machine ${machineId} has no referenceModels array - initializing empty array`);\n    machine.referenceModels = [];\n  }\n\n  // Add model to the collection\n  machine.referenceModels.push(model);\n  await db.put('machines', machine);\n\n  logger.info(`üß† Model '${model.label}' added to machine: ${machineId}`);\n}\n\n// ============================================================================\n// RECORDING OPERATIONS\n// ============================================================================\n\n/**\n * Save a recording\n *\n * CRITICAL FIX: Serialize AudioBuffer before storing in IndexedDB\n * AudioBuffer is not structure-cloneable and will cause DataCloneError if stored directly.\n * We serialize it to a plain object that IndexedDB can handle.\n *\n * @param recording - Recording object\n */\nexport async function saveRecording(recording: Recording): Promise<void> {\n  const db = await initDB();\n\n  // Serialize AudioBuffer for IndexedDB storage\n  const serializedRecording: SerializedRecording = {\n    ...recording,\n    audioBuffer: serializeAudioBuffer(recording.audioBuffer),\n  };\n\n  await db.put('recordings', serializedRecording as unknown as Recording);\n  logger.info(`üéôÔ∏è Recording saved: ${recording.id}`);\n}\n\n/**\n * Get recording by ID\n *\n * CRITICAL FIX: Deserialize AudioBuffer after loading from IndexedDB\n * The stored recording has a serialized AudioBuffer that needs to be converted back.\n *\n * @param id - Recording ID\n * @returns Recording or undefined\n */\nexport async function getRecording(id: string): Promise<Recording | undefined> {\n  const db = await initDB();\n  const storedRecording = await db.get('recordings', id);\n\n  if (!storedRecording) {\n    return undefined;\n  }\n\n  // Deserialize AudioBuffer if it's in serialized format\n  if (isSerializedAudioBuffer(storedRecording.audioBuffer)) {\n    return {\n      ...storedRecording,\n      audioBuffer: deserializeAudioBuffer(storedRecording.audioBuffer),\n    } as Recording;\n  }\n\n  // Already deserialized (shouldn't happen, but handle gracefully)\n  return storedRecording as Recording;\n}\n\n/**\n * Get all recordings for a machine\n *\n * CRITICAL FIX: Deserialize AudioBuffers after loading from IndexedDB\n * The stored recordings have serialized AudioBuffers that need to be converted back.\n *\n * @param machineId - Machine ID\n * @returns Array of recordings\n */\nexport async function getRecordingsForMachine(machineId: string): Promise<Recording[]> {\n  const db = await initDB();\n  const storedRecordings = await db.getAllFromIndex('recordings', 'by-machine', machineId);\n\n  // Deserialize all AudioBuffers\n  return storedRecordings.map((recording) => {\n    if (isSerializedAudioBuffer(recording.audioBuffer)) {\n      return {\n        ...recording,\n        audioBuffer: deserializeAudioBuffer(recording.audioBuffer),\n      } as Recording;\n    }\n    return recording as Recording;\n  });\n}\n\n// ============================================================================\n// DIAGNOSIS OPERATIONS\n// ============================================================================\n\n/**\n * Save a diagnosis result\n *\n * @param diagnosis - Diagnosis result\n */\nexport async function saveDiagnosis(diagnosis: DiagnosisResult): Promise<void> {\n  const db = await initDB();\n  await db.put('diagnoses', diagnosis);\n\n  // Update machine's last diagnosis timestamp\n  const machine = await db.get('machines', diagnosis.machineId);\n  if (machine) {\n    machine.lastDiagnosisAt = diagnosis.timestamp;\n    await db.put('machines', machine);\n  }\n\n  logger.info(`üìä Diagnosis saved for machine: ${diagnosis.machineId}`);\n}\n\n/**\n * Get all diagnoses for a machine\n *\n * OPTIMIZED: Uses cursor-based approach when limit is specified to avoid loading\n * all records into memory. This prevents performance issues with large datasets.\n *\n * @param machineId - Machine ID\n * @param limit - Maximum number of results (optional, recommended for large datasets)\n * @returns Array of diagnoses (sorted by timestamp, newest first)\n */\nexport async function getDiagnosesForMachine(\n  machineId: string,\n  limit?: number\n): Promise<DiagnosisResult[]> {\n  const db = await initDB();\n  const diagnoses: DiagnosisResult[] = [];\n  const maxResults = limit !== undefined ? limit : Number.POSITIVE_INFINITY;\n\n  if (maxResults <= 0) {\n    return diagnoses;\n  }\n\n  const range = IDBKeyRange.bound([machineId, -Infinity], [machineId, Infinity]);\n\n  let cursor = await db\n    .transaction('diagnoses')\n    .store.index('by-machine-timestamp')\n    .openCursor(range, 'prev');\n\n  while (cursor && diagnoses.length < maxResults) {\n    diagnoses.push(cursor.value as DiagnosisResult);\n    cursor = await cursor.continue();\n  }\n\n  return diagnoses;\n}\n\n/**\n * Get latest diagnosis for a machine\n *\n * @param machineId - Machine ID\n * @returns Latest diagnosis or undefined\n */\nexport async function getLatestDiagnosis(machineId: string): Promise<DiagnosisResult | undefined> {\n  const diagnoses = await getDiagnosesForMachine(machineId, 1);\n  return diagnoses[0];\n}\n\n/**\n * Get diagnoses by status\n *\n * @param status - Health status\n * @returns Array of diagnoses\n */\nexport async function getDiagnosesByStatus(\n  status: DiagnosisResult['status']\n): Promise<DiagnosisResult[]> {\n  const db = await initDB();\n  return await db.getAllFromIndex('diagnoses', 'by-status', status);\n}\n\n// ============================================================================\n// UTILITY OPERATIONS\n// ============================================================================\n\n/**\n * Clear all data from database (for testing/reset)\n */\nexport async function clearAllData(): Promise<void> {\n  const db = await initDB();\n\n  await db.clear('machines');\n  await db.clear('recordings');\n  await db.clear('diagnoses');\n\n  logger.info('üóëÔ∏è All data cleared');\n}\n\n/**\n * Get database statistics\n *\n * @returns Database statistics\n */\nexport async function getDBStats(): Promise<{\n  machines: number;\n  recordings: number;\n  diagnoses: number;\n}> {\n  const db = await initDB();\n\n  const machines = await db.count('machines');\n  const recordings = await db.count('recordings');\n  const diagnoses = await db.count('diagnoses');\n\n  return { machines, recordings, diagnoses };\n}\n\n/**\n * Serialized AudioBuffer for JSON export\n */\ninterface SerializedAudioBuffer {\n  _serialized: true;\n  numberOfChannels: number;\n  sampleRate: number;\n  length: number;\n  duration: number;\n  channelData: number[][]; // Array of Arrays (Float32Array ‚Üí number[])\n}\n\n/**\n * Serialized Recording for JSON export\n */\ninterface SerializedRecording extends Omit<Recording, 'audioBuffer'> {\n  audioBuffer: SerializedAudioBuffer;\n}\n\n/**\n * Serialized Machine for JSON export\n */\ninterface SerializedMachine extends Omit<Machine, 'referenceModels'> {\n  referenceModels: Array<Omit<GMIAModel, 'weightVector'> & { weightVector: number[] }>;\n}\n\n/**\n * Serialize AudioBuffer to JSON-compatible format\n *\n * @param audioBuffer - Web Audio API AudioBuffer\n * @returns Serialized format with Float32Array data\n */\nfunction serializeAudioBuffer(audioBuffer: AudioBuffer): SerializedAudioBuffer {\n  const channelData: number[][] = [];\n\n  // Extract all channel data\n  for (let i = 0; i < audioBuffer.numberOfChannels; i++) {\n    const data = audioBuffer.getChannelData(i);\n    channelData.push(Array.from(data)); // Float32Array ‚Üí number[]\n  }\n\n  return {\n    _serialized: true,\n    numberOfChannels: audioBuffer.numberOfChannels,\n    sampleRate: audioBuffer.sampleRate,\n    length: audioBuffer.length,\n    duration: audioBuffer.duration,\n    channelData,\n  };\n}\n\n/**\n * Export all data (for backup)\n *\n * @returns All database data with serialized AudioBuffers\n */\nexport async function exportData(): Promise<{\n  machines: SerializedMachine[];\n  recordings: SerializedRecording[];\n  diagnoses: DiagnosisResult[];\n}> {\n  const db = await initDB();\n\n  const machines = await db.getAll('machines');\n  const serializedMachines: SerializedMachine[] = machines.map((machine) => ({\n    ...machine,\n    referenceModels: (machine.referenceModels || []).map((model) => ({\n      ...model,\n      weightVector: Array.from(model.weightVector),\n    })),\n  }));\n  const recordings = await db.getAll('recordings');\n  const diagnoses = await db.getAll('diagnoses');\n\n  // CRITICAL FIX: Check if AudioBuffers are already serialized\n  // Recordings in IndexedDB are already serialized by saveRecording()\n  // Attempting to serialize again causes crash (no getChannelData method on plain objects)\n  const serializedRecordings = recordings.map((recording) => {\n    if (isSerializedAudioBuffer(recording.audioBuffer)) {\n      // Already serialized - use directly\n      // CRITICAL FIX: Use explicit unknown cast to indicate intentional type conversion\n      // This is safe because we've verified the audioBuffer is already serialized\n      return recording as unknown as SerializedRecording;\n    }\n\n    // Not serialized yet - serialize now (shouldn't happen with current saveRecording, but handle gracefully)\n    return {\n      ...recording,\n      audioBuffer: serializeAudioBuffer(recording.audioBuffer),\n    };\n  });\n\n  logger.info('üì¶ Data exported successfully');\n\n  return { machines: serializedMachines, recordings: serializedRecordings, diagnoses };\n}\n\n/**\n * Deserialize AudioBuffer from JSON format\n *\n * CRITICAL FIX: Close AudioContext after use to prevent resource leaks\n * Each AudioContext consumes browser resources. Creating many without closing\n * can lead to \"Too many AudioContexts\" errors and instability.\n *\n * @param serialized - Serialized AudioBuffer data\n * @returns Web Audio API AudioBuffer\n */\nfunction deserializeAudioBuffer(serialized: SerializedAudioBuffer): AudioBuffer {\n  // Create OfflineAudioContext instead of AudioContext for better resource management\n  // OfflineAudioContext is designed for processing and is automatically cleaned up\n  const audioContext = new OfflineAudioContext(\n    serialized.numberOfChannels,\n    serialized.length,\n    serialized.sampleRate\n  );\n\n  // Create empty AudioBuffer\n  const audioBuffer = audioContext.createBuffer(\n    serialized.numberOfChannels,\n    serialized.length,\n    serialized.sampleRate\n  );\n\n  // Fill channel data\n  for (let i = 0; i < serialized.numberOfChannels; i++) {\n    const channelData = audioBuffer.getChannelData(i);\n    const sourceData = serialized.channelData[i];\n\n    for (let j = 0; j < sourceData.length; j++) {\n      channelData[j] = sourceData[j];\n    }\n  }\n\n  // OfflineAudioContext doesn't need explicit closing\n  // It's designed for synchronous buffer creation and is auto-managed\n  // No need for try/finally or async close() calls\n\n  return audioBuffer;\n}\n\n/**\n * Check if an object is a serialized AudioBuffer\n *\n * @param obj - Object to check\n * @returns True if object is serialized AudioBuffer\n */\nfunction isSerializedAudioBuffer(obj: unknown): obj is SerializedAudioBuffer {\n  return (\n    obj !== null &&\n    obj !== undefined &&\n    typeof obj === 'object' &&\n    '_serialized' in obj &&\n    obj._serialized === true &&\n    'numberOfChannels' in obj &&\n    typeof obj.numberOfChannels === 'number' &&\n    'sampleRate' in obj &&\n    typeof obj.sampleRate === 'number' &&\n    'length' in obj &&\n    typeof obj.length === 'number' &&\n    'channelData' in obj &&\n    Array.isArray(obj.channelData)\n  );\n}\n\n/**\n * Import data (restore from backup)\n *\n * @param data - Data to import\n * @param merge - If true, merge with existing data; if false, replace all data\n */\nexport async function importData(\n  data: {\n    machines?: Machine[];\n    recordings?: (Recording | SerializedRecording)[];\n    diagnoses?: DiagnosisResult[];\n  },\n  merge: boolean = false\n): Promise<void> {\n  const db = await initDB();\n\n  // If not merging, clear existing data first\n  if (!merge) {\n    await clearAllData();\n    logger.info('üóëÔ∏è Existing data cleared for import');\n  }\n\n  // Import machines\n  if (data.machines) {\n    for (const machine of data.machines) {\n      const normalizedMachine: Machine = {\n        ...machine,\n        referenceModels: (machine.referenceModels || []).map((model) => ({\n          ...model,\n          weightVector:\n            model.weightVector instanceof Float64Array\n              ? model.weightVector\n              : new Float64Array(model.weightVector as number[]),\n        })),\n      };\n      await db.put('machines', normalizedMachine);\n    }\n    logger.info(`üì• Imported ${data.machines.length} machines`);\n  }\n\n  // Import recordings with AudioBuffer rehydration\n  if (data.recordings) {\n    for (const recording of data.recordings) {\n      // CRITICAL FIX: IndexedDB requires serialized AudioBuffers, not real AudioBuffer objects\n      // AudioBuffer is not structure-cloneable and causes DataCloneError\n      let serializedRecording: SerializedRecording;\n\n      if (isSerializedAudioBuffer(recording.audioBuffer)) {\n        // Already serialized - use directly (format matches IndexedDB storage)\n        serializedRecording = recording as SerializedRecording;\n      } else {\n        // Real AudioBuffer - serialize it before storing in IndexedDB\n        serializedRecording = {\n          ...recording,\n          audioBuffer: serializeAudioBuffer(recording.audioBuffer as AudioBuffer),\n        };\n      }\n\n      await db.put('recordings', serializedRecording as unknown as Recording);\n    }\n    logger.info(`üì• Imported ${data.recordings.length} recordings`);\n  }\n\n  // Import diagnoses\n  if (data.diagnoses) {\n    for (const diagnosis of data.diagnoses) {\n      await db.put('diagnoses', diagnosis);\n    }\n    logger.info(`üì• Imported ${data.diagnoses.length} diagnoses`);\n  }\n\n  logger.info('‚úÖ Data import complete');\n}\n"],"names":["getDefaultConfig","Logger","config","__publicField","message","args","error","errorInfo","stack","level","logFn","timestamp","prefix","logger","DB_NAME","DB_VERSION","dbInstance","initDB","openDB","db","oldVersion","newVersion","transaction","machineStore","recordingStore","diagnosisStore","e","saveMachine","machine","getMachine","id","getAllMachines","updateMachineModel","machineId","model","saveDiagnosis","diagnosis","clearAllData","getDBStats","machines","recordings","diagnoses","serializeAudioBuffer","audioBuffer","channelData","i","data","exportData","serializedMachines","serializedRecordings","recording","isSerializedAudioBuffer","obj","importData","merge","normalizedMachine","serializedRecording"],"mappings":"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"}