{"version":3,"file":"dsp-CDZtT2db.js","sources":["../../src/core/dsp/fft.ts","../../src/core/dsp/features.ts"],"sourcesContent":["/**\n * ZANOBOT - FFT (Fast Fourier Transform)\n *\n * Implements FFT for audio signal processing.\n * Based on Cooley-Tukey radix-2 algorithm.\n */\n\n/**\n * Complex number representation\n */\ninterface Complex {\n  real: number;\n  imag: number;\n}\n\n/**\n * Perform FFT on real-valued input signal\n *\n * Uses iterative Cooley-Tukey algorithm with bit-reversal.\n * Prevents stack overflow for large inputs.\n *\n * @param signal - Input time-domain signal (must be power of 2 length)\n * @returns Complex frequency-domain representation\n */\nexport function fft(signal: Float32Array): Complex[] {\n  const n = signal.length;\n\n  // Ensure input length is power of 2\n  if (!isPowerOfTwo(n)) {\n    throw new Error(`FFT input length must be power of 2, got ${n}`);\n  }\n\n  // Convert real signal to complex\n  const complex: Complex[] = Array.from(signal, (real) => ({ real, imag: 0 }));\n\n  // Perform iterative FFT (no recursion, no stack overflow)\n  return fftIterative(complex);\n}\n\n/**\n * Iterative FFT implementation (Cooley-Tukey with bit-reversal)\n *\n * Advantages over recursive:\n * - No stack overflow for large inputs\n * - Better performance (no function call overhead)\n * - More memory efficient\n *\n * Algorithm:\n * 1. Bit-reversal permutation\n * 2. Butterfly operations in log2(n) stages\n *\n * @internal - Exported only for testing purposes\n */\nexport function fftIterative(x: Complex[]): Complex[] {\n  const n = x.length;\n  const result = [...x]; // Copy input\n\n  // Step 1: Bit-reversal permutation\n  const numBits = Math.log2(n);\n  for (let i = 0; i < n; i++) {\n    const reversed = reverseBits(i, numBits);\n    if (reversed > i) {\n      // Swap\n      [result[i], result[reversed]] = [result[reversed], result[i]];\n    }\n  }\n\n  // Step 2: Butterfly operations (bottom-up)\n  for (let size = 2; size <= n; size *= 2) {\n    const halfSize = size / 2;\n    const step = (2 * Math.PI) / size;\n\n    for (let i = 0; i < n; i += size) {\n      for (let j = 0; j < halfSize; j++) {\n        // Twiddle factor: e^(-2πij/size)\n        const angle = -step * j;\n        const twiddle: Complex = {\n          real: Math.cos(angle),\n          imag: Math.sin(angle),\n        };\n\n        // Butterfly operation\n        const evenIdx = i + j;\n        const oddIdx = i + j + halfSize;\n\n        const t = complexMultiply(twiddle, result[oddIdx]);\n        const even = result[evenIdx];\n\n        result[evenIdx] = complexAdd(even, t);\n        result[oddIdx] = complexSubtract(even, t);\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Reverse bits of a number\n *\n * Used for bit-reversal permutation in iterative FFT.\n *\n * @param num - Number to reverse\n * @param numBits - Number of bits to consider\n * @returns Bit-reversed number\n */\nfunction reverseBits(num: number, numBits: number): number {\n  let reversed = 0;\n  for (let i = 0; i < numBits; i++) {\n    reversed = (reversed << 1) | (num & 1);\n    num >>= 1;\n  }\n  return reversed;\n}\n\n/**\n * Recursive FFT implementation (Cooley-Tukey)\n *\n * @deprecated Use iterative implementation instead (fftIterative)\n * Kept for reference and validation testing.\n * @internal - Exported only for testing purposes\n */\nexport function fftRecursive(x: Complex[]): Complex[] {\n  const n = x.length;\n\n  // Base case\n  if (n === 1) {\n    return x;\n  }\n\n  // Divide\n  const even: Complex[] = [];\n  const odd: Complex[] = [];\n\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      even.push(x[i]);\n    } else {\n      odd.push(x[i]);\n    }\n  }\n\n  // Conquer\n  const fftEven = fftRecursive(even);\n  const fftOdd = fftRecursive(odd);\n\n  // Combine\n  const result: Complex[] = new Array(n);\n\n  for (let k = 0; k < n / 2; k++) {\n    // Twiddle factor: e^(-2πik/n)\n    const angle = (-2 * Math.PI * k) / n;\n    const twiddle: Complex = {\n      real: Math.cos(angle),\n      imag: Math.sin(angle),\n    };\n\n    // Complex multiplication: twiddle * fftOdd[k]\n    const t: Complex = complexMultiply(twiddle, fftOdd[k]);\n\n    // Butterfly operation\n    result[k] = complexAdd(fftEven[k], t);\n    result[k + n / 2] = complexSubtract(fftEven[k], t);\n  }\n\n  return result;\n}\n\n/**\n * Calculate magnitude (absolute value) of FFT output\n *\n * Uses Math.hypot for better numerical stability and overflow prevention.\n *\n * @param fftResult - Complex FFT output\n * @returns Magnitude spectrum (real values)\n */\nexport function getMagnitude(fftResult: Complex[]): Float64Array {\n  const magnitude = new Float64Array(fftResult.length);\n\n  for (let i = 0; i < fftResult.length; i++) {\n    const { real, imag } = fftResult[i];\n    // Use Math.hypot for numerical stability (prevents overflow)\n    magnitude[i] = Math.hypot(real, imag);\n  }\n\n  return magnitude;\n}\n\n/**\n * Calculate power spectrum (magnitude squared)\n *\n * @param fftResult - Complex FFT output\n * @returns Power spectrum\n */\nexport function getPowerSpectrum(fftResult: Complex[]): Float64Array {\n  const power = new Float64Array(fftResult.length);\n\n  for (let i = 0; i < fftResult.length; i++) {\n    const { real, imag } = fftResult[i];\n    power[i] = real * real + imag * imag;\n  }\n\n  return power;\n}\n\n/**\n * Apply Hanning window to reduce spectral leakage\n *\n * @param signal - Input signal\n * @returns Windowed signal\n */\nexport function applyHanningWindow(signal: Float32Array): Float32Array {\n  const n = signal.length;\n  const windowed = new Float32Array(n);\n\n  for (let i = 0; i < n; i++) {\n    const windowValue = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (n - 1)));\n    windowed[i] = signal[i] * windowValue;\n  }\n\n  return windowed;\n}\n\n/**\n * Pad signal to next power of 2 length\n *\n * @param signal - Input signal\n * @returns Zero-padded signal\n */\nexport function padToPowerOfTwo(signal: Float32Array): Float32Array {\n  const n = signal.length;\n  const nextPower = nextPowerOfTwo(n);\n\n  if (n === nextPower) {\n    return signal;\n  }\n\n  const padded = new Float32Array(nextPower);\n  padded.set(signal);\n\n  return padded;\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction complexAdd(a: Complex, b: Complex): Complex {\n  return {\n    real: a.real + b.real,\n    imag: a.imag + b.imag,\n  };\n}\n\nfunction complexSubtract(a: Complex, b: Complex): Complex {\n  return {\n    real: a.real - b.real,\n    imag: a.imag - b.imag,\n  };\n}\n\nfunction complexMultiply(a: Complex, b: Complex): Complex {\n  return {\n    real: a.real * b.real - a.imag * b.imag,\n    imag: a.real * b.imag + a.imag * b.real,\n  };\n}\n\nfunction isPowerOfTwo(n: number): boolean {\n  return n > 0 && (n & (n - 1)) === 0;\n}\n\nfunction nextPowerOfTwo(n: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(n)));\n}\n","/**\n * ZANOBOT - FEATURE EXTRACTION\n *\n * Extracts Energy Spectral Densities from audio signals.\n * This is THE core feature extraction method for GMIA.\n *\n * - Chunking: 0.330s windows with 0.066s hop size\n * - FFT: Calculate frequency spectrum\n * - Binning: Group into 512 frequency bins\n * - Normalization: Relative features (sum = 1)\n */\n\nimport { fft, getMagnitude, applyHanningWindow, padToPowerOfTwo } from './fft.js';\nimport type { FeatureVector, AudioChunk, DSPConfig } from '@data/types.js';\nimport { logger } from '@utils/logger.js';\n\n/**\n * Default DSP configuration for GMIA\n */\nexport const DEFAULT_DSP_CONFIG: DSPConfig = {\n  sampleRate: 48000, // High quality audio sample rate (matches config.json)\n  windowSize: 0.33, // 330ms\n  hopSize: 0.066, // 66ms overlap\n  fftSize: 2048, // Fixed FFT size (matches config.json)\n  frequencyBins: 512, // Tested optimal value (Report p.19)\n  frequencyRange: [0, 24000], // 0 to Nyquist frequency (48000/2)\n};\n\n/**\n * Extract Energy Spectral Densities from audio buffer\n *\n * This is the main entry point for feature extraction.\n *\n * @param audioBuffer - Web Audio API AudioBuffer\n * @param config - DSP configuration (optional)\n * @returns Array of feature vectors (one per chunk)\n * @throws Error if audio buffer is too short to extract any features\n */\nexport function extractFeatures(\n  audioBuffer: AudioBuffer,\n  config: DSPConfig = DEFAULT_DSP_CONFIG\n): FeatureVector[] {\n  // CRITICAL FIX: Validate sample rate before using it\n  // Prevents mathematical errors from invalid sample rates (0, NaN, Infinity, negative)\n  if (\n    !audioBuffer.sampleRate ||\n    !isFinite(audioBuffer.sampleRate) ||\n    audioBuffer.sampleRate <= 0 ||\n    audioBuffer.sampleRate > 192000\n  ) {\n    throw new Error(\n      `Ungültige Sample Rate: ${audioBuffer.sampleRate}Hz. ` +\n      `Erwartet: 8000-192000Hz (typisch: 44100Hz oder 48000Hz)`\n    );\n  }\n\n  // OPTIMIZATION: Check if config needs adjustment for actual audio buffer sample rate\n  // Improves readability by separating condition from conditional assignment\n  const needsSampleRateAdjustment =\n    config.sampleRate !== audioBuffer.sampleRate ||\n    config.frequencyRange[1] !== audioBuffer.sampleRate / 2;\n\n  const effectiveConfig = needsSampleRateAdjustment\n    ? {\n        ...config,\n        sampleRate: audioBuffer.sampleRate,\n        frequencyRange: [0, audioBuffer.sampleRate / 2] as [number, number],\n      }\n    : config;\n\n  // CRITICAL FIX: Validate frequency range\n  const [minFreq, maxFreq] = effectiveConfig.frequencyRange;\n  if (!isFinite(minFreq) || !isFinite(maxFreq) || minFreq < 0 || maxFreq <= minFreq) {\n    throw new Error(\n      `Invalid frequency range: [${minFreq}, ${maxFreq}]Hz. ` +\n      `Min must be >= 0, Max must be > Min, both must be finite.`\n    );\n  }\n\n  // Validate against Nyquist frequency\n  const nyquistFreq = effectiveConfig.sampleRate / 2;\n  if (maxFreq > nyquistFreq) {\n    throw new Error(\n      `Frequency range max (${maxFreq}Hz) exceeds Nyquist frequency (${nyquistFreq}Hz) ` +\n      `for sample rate ${effectiveConfig.sampleRate}Hz`\n    );\n  }\n\n  // Validate audio buffer duration (both minimum and maximum)\n  const minDuration = effectiveConfig.windowSize; // At least one window size\n  const maxDuration = 300; // 5 minutes maximum to prevent browser freeze\n\n  if (audioBuffer.duration < minDuration) {\n    throw new Error(\n      `Audio buffer too short: ${audioBuffer.duration.toFixed(2)}s (minimum: ${minDuration.toFixed(2)}s)`\n    );\n  }\n\n  if (audioBuffer.duration > maxDuration) {\n    logger.warn(\n      `⚠️ Audio buffer very long (${audioBuffer.duration.toFixed(1)}s), ` +\n      `this may cause performance issues. Maximum recommended: ${maxDuration}s`\n    );\n    // Note: We continue processing but warn the user\n    // Truncation would require more complex buffer manipulation\n  }\n\n  // Get mono channel data\n  const channelData = getMonoChannel(audioBuffer);\n\n  // Split into chunks (0.330s windows with 0.066s overlap)\n  const chunks = chunkSignal(channelData, audioBuffer.sampleRate, effectiveConfig);\n\n  // Ensure we have at least one chunk\n  if (chunks.length === 0) {\n    throw new Error('Failed to extract any audio chunks - signal too short');\n  }\n\n  // Extract features from each chunk\n  const features = chunks.map((chunk) => extractChunkFeatures(chunk, effectiveConfig));\n\n  return features;\n}\n\n/**\n * Extract features from a raw audio chunk (for real-time processing)\n *\n * Optimized for live stream processing - no AudioBuffer overhead.\n * Use this for real-time feedback loops where chunks are continuously processed.\n *\n * @param samples - Raw audio samples (Float32Array)\n * @param config - DSP configuration\n * @returns Feature vector\n */\nexport function extractFeaturesFromChunk(\n  samples: Float32Array,\n  config: DSPConfig = DEFAULT_DSP_CONFIG\n): FeatureVector {\n  const chunk: AudioChunk = {\n    samples,\n    startTime: 0,\n    duration: samples.length / config.sampleRate,\n    normalized: false,\n  };\n\n  return extractChunkFeatures(chunk, config);\n}\n\n/**\n * Extract features from a single audio chunk\n *\n * Steps:\n * 1. Standardize (mean removal + variance scaling)\n * 2. Apply windowing (Hanning)\n * 3. Compute FFT\n * 4. Calculate energy per frequency bin\n * 5. Bin into frequency groups (512 bins)\n * 6. Normalize to relative features\n *\n * @param chunk - Audio chunk\n * @param config - DSP configuration\n * @returns Feature vector\n */\nfunction extractChunkFeatures(chunk: AudioChunk, config: DSPConfig): FeatureVector {\n  // Step 0: CRITICAL - Calculate RMS amplitude BEFORE standardization\n  // This preserves the actual signal strength for quality assessment and magnitude checks\n  let rmsSum = 0;\n  for (let i = 0; i < chunk.samples.length; i++) {\n    rmsSum += chunk.samples[i] * chunk.samples[i];\n  }\n  const rmsAmplitude = Math.sqrt(rmsSum / chunk.samples.length);\n\n  // Step 1: Standardize the chunk\n  const standardized = standardizeSignal(chunk.samples);\n\n  // CRITICAL FIX: Validate standardized signal is not degenerate\n  // If RMS of standardized signal is too low, use non-standardized signal instead\n  let standardizedRms = 0;\n  for (let i = 0; i < standardized.length; i++) {\n    standardizedRms += standardized[i] * standardized[i];\n  }\n  standardizedRms = Math.sqrt(standardizedRms / standardized.length);\n\n  let signalToUse = standardized;\n  if (standardizedRms < 1e-6) {\n    logger.warn(`⚠️ Standardization produced near-zero signal (RMS=${standardizedRms.toExponential(2)}), using non-standardized signal instead`);\n    signalToUse = chunk.samples; // Use original signal\n  }\n\n  // Step 2: Apply Hanning window\n  const windowed = applyHanningWindow(signalToUse);\n\n  // Step 3: Pad to power of 2 for FFT efficiency\n  const padded = padToPowerOfTwo(windowed);\n\n  // Step 4: Compute FFT\n  const fftResult = fft(padded);\n\n  // Step 5: Get magnitude (energy)\n  const magnitude = getMagnitude(fftResult);\n\n  // Step 6: Only use positive frequencies (0 to Nyquist)\n  const positiveFreqs = magnitude.slice(0, magnitude.length / 2);\n\n  // Step 7: Bin into frequency groups\n  const binnedEnergy = binFrequencies(positiveFreqs, config.frequencyBins);\n\n  // CRITICAL VALIDATION: Check if features are degenerate (all zeros or near-zeros)\n  let totalEnergy = 0;\n  for (let i = 0; i < binnedEnergy.length; i++) {\n    totalEnergy += binnedEnergy[i];\n  }\n\n  if (totalEnergy < 1e-10) {\n    logger.error(`❌ Feature extraction failed: Total energy = ${totalEnergy.toExponential(2)} (degenerate signal)`);\n    logger.error(`   This indicates the signal is too constant or silent.`);\n    logger.error(`   RMS amplitude: ${rmsAmplitude.toFixed(6)}`);\n    throw new Error(\n      `Feature extraction failed: Signal is too constant or silent (total energy = ${totalEnergy.toExponential(2)}). ` +\n      `This can happen with very stable noise sources. Please ensure the signal has sufficient variation.`\n    );\n  }\n\n  // Step 8: Calculate relative features (sum = 1)\n  const relativeFeatures = normalizeFeatures(binnedEnergy);\n\n  return {\n    features: relativeFeatures,\n    absoluteFeatures: binnedEnergy,\n    bins: config.frequencyBins,\n    frequencyRange: [0, config.sampleRate / 2],\n    rmsAmplitude: rmsAmplitude, // CRITICAL: Pre-standardization RMS for amplitude checks\n  };\n}\n\n/**\n * Chunk signal into overlapping windows\n *\n * @param signal - Full audio signal\n * @param sampleRate - Sample rate (Hz)\n * @param config - DSP configuration\n * @returns Array of audio chunks\n */\nfunction chunkSignal(signal: Float32Array, sampleRate: number, config: DSPConfig): AudioChunk[] {\n  const windowSamples = Math.floor(config.windowSize * sampleRate);\n  const hopSamples = Math.floor(config.hopSize * sampleRate);\n\n  const chunks: AudioChunk[] = [];\n  let offset = 0;\n\n  while (offset + windowSamples <= signal.length) {\n    const samples = signal.slice(offset, offset + windowSamples);\n\n    chunks.push({\n      samples,\n      startTime: offset / sampleRate,\n      duration: config.windowSize,\n      normalized: false,\n    });\n\n    offset += hopSamples;\n  }\n\n  return chunks;\n}\n\n/**\n * Standardize signal (zero mean, unit variance)\n *\n * Critical preprocessing step for GMIA.\n *\n * @param signal - Input signal\n * @returns Standardized signal\n */\nfunction standardizeSignal(signal: Float32Array): Float32Array {\n  const n = signal.length;\n\n  // Calculate mean\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    sum += signal[i];\n  }\n  const mean = sum / n;\n\n  // Calculate variance\n  let varianceSum = 0;\n  for (let i = 0; i < n; i++) {\n    const diff = signal[i] - mean;\n    varianceSum += diff * diff;\n  }\n  const variance = varianceSum / n;\n  const stdDev = Math.sqrt(variance);\n\n  // CRITICAL FIX: If signal is too constant (stdDev ≈ 0), skip standardization\n  // This prevents division by zero and generating all-zero feature vectors\n  // Threshold: 1e-6 allows very stable signals while protecting against pure constants\n  const MIN_STDDEV = 1e-6;\n\n  if (stdDev < MIN_STDDEV) {\n    logger.warn(`⚠️ Signal too constant (stdDev=${stdDev.toExponential(2)}), skipping standardization`);\n    // Return mean-centered signal without variance scaling\n    const standardized = new Float32Array(n);\n    for (let i = 0; i < n; i++) {\n      standardized[i] = signal[i] - mean;\n    }\n    return standardized;\n  }\n\n  // Standardize normally (mean=0, variance=1)\n  const standardized = new Float32Array(n);\n  for (let i = 0; i < n; i++) {\n    standardized[i] = (signal[i] - mean) / stdDev;\n  }\n\n  return standardized;\n}\n\n/**\n * Bin frequencies into groups\n *\n * Groups the FFT output into N equally-spaced bins.\n * Calculates \"Square Root Mean Value\" for each bin.\n *\n * @param magnitudes - FFT magnitude spectrum\n * @param numBins - Number of bins (default: 512)\n * @returns Binned energy values\n */\nfunction binFrequencies(magnitudes: Float64Array, numBins: number): Float64Array {\n  const binnedEnergy = new Float64Array(numBins);\n  const binSize = Math.floor(magnitudes.length / numBins);\n\n  for (let bin = 0; bin < numBins; bin++) {\n    const startIdx = bin * binSize;\n    const endIdx = bin === numBins - 1 ? magnitudes.length : (bin + 1) * binSize;\n\n    // Calculate Square Root Mean Value\n    let sum = 0;\n    let count = 0;\n\n    for (let i = startIdx; i < endIdx; i++) {\n      sum += magnitudes[i] * magnitudes[i]; // Energy = magnitude^2\n      count++;\n    }\n\n    const meanSquare = count > 0 ? sum / count : 0;\n    binnedEnergy[bin] = Math.sqrt(meanSquare);\n  }\n\n  return binnedEnergy;\n}\n\n/**\n * Normalize features to relative values (sum = 1)\n *\n * Formula: rf_j = f_j / f_tot\n *\n * @param features - Absolute feature values\n * @returns Normalized relative features\n */\nfunction normalizeFeatures(features: Float64Array): Float64Array {\n  const n = features.length;\n\n  // Calculate total energy\n  let total = 0;\n  for (let i = 0; i < n; i++) {\n    total += features[i];\n  }\n\n  // Normalize\n  const normalized = new Float64Array(n);\n\n  if (total > 0) {\n    for (let i = 0; i < n; i++) {\n      normalized[i] = features[i] / total;\n    }\n  }\n\n  return normalized;\n}\n\n/**\n * Convert stereo to mono by averaging channels\n *\n * @param audioBuffer - Web Audio API buffer\n * @returns Mono channel data\n */\nfunction getMonoChannel(audioBuffer: AudioBuffer): Float32Array {\n  if (audioBuffer.numberOfChannels === 1) {\n    return audioBuffer.getChannelData(0);\n  }\n\n  // Average all channels\n  const length = audioBuffer.length;\n  const mono = new Float32Array(length);\n\n  for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {\n    const channelData = audioBuffer.getChannelData(channel);\n    for (let i = 0; i < length; i++) {\n      mono[i] += channelData[i];\n    }\n  }\n\n  // Divide by number of channels\n  for (let i = 0; i < length; i++) {\n    mono[i] /= audioBuffer.numberOfChannels;\n  }\n\n  return mono;\n}\n\n/**\n * Calculate frequency for a given bin index\n *\n * @param binIndex - Bin index\n * @param numBins - Total number of bins\n * @param sampleRate - Sample rate (Hz)\n * @returns Frequency in Hz\n */\nexport function binToFrequency(binIndex: number, numBins: number, sampleRate: number): number {\n  const nyquist = sampleRate / 2;\n  return (binIndex / numBins) * nyquist;\n}\n"],"names":["fft","signal","n","isPowerOfTwo","complex","real","fftIterative","x","result","numBits","i","reversed","reverseBits","size","halfSize","step","j","angle","twiddle","evenIdx","oddIdx","t","complexMultiply","even","complexAdd","complexSubtract","num","getMagnitude","fftResult","magnitude","imag","applyHanningWindow","windowed","windowValue","padToPowerOfTwo","nextPower","nextPowerOfTwo","padded","a","b","DEFAULT_DSP_CONFIG","extractFeatures","audioBuffer","config","effectiveConfig","minFreq","maxFreq","nyquistFreq","minDuration","maxDuration","logger","channelData","getMonoChannel","chunks","chunkSignal","chunk","extractChunkFeatures","extractFeaturesFromChunk","samples","rmsSum","rmsAmplitude","standardized","standardizeSignal","standardizedRms","signalToUse","positiveFreqs","binnedEnergy","binFrequencies","totalEnergy","normalizeFeatures","sampleRate","windowSamples","hopSamples","offset","sum","mean","varianceSum","diff","variance","stdDev","magnitudes","numBins","binSize","bin","startIdx","endIdx","count","meanSquare","features","total","normalized","length","mono","channel"],"mappings":"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"}